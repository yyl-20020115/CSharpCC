namespace org.javacc.parser;


// A simple class to hold the data generated by the tokenizer. This is passed to
// the code generators to produce code.
public class TokenizerData {

  // Name of the parser as specified in the PARSER_BEGIN/PARSER_END block.
  public string parserName;

  // Decls coming from TOKEN_MGR_DECLS
  public string decls;

  // A map of <LexState, first char> to a sequence of literals indexed by:
  //      ((int0LexicalState << 16 | (int)c)
  // The literals in the list are all guaranteed to start with the char and re
  // sorted by length so that the "longest-match" rule is done trivially by
  // just going through the sequence in the order.
  // Since they are all literals, there is no duplication (JavaCC checks that)
  // and hence if a longer match is matched, no need to check the shorter match.
  public Dictionary<int, List<String>> literalSequence;

  // A map of list of kind values indexed by ((int0LexicalState << 16 | (int)c)
  // same key as before.
  public Dictionary<int, List<int>> literalKinds;

  // The NFA start state for a given string literal match. We use this to start
  // the NFA if needed after a literal match is completed.
  public Dictionary<int, int> kindToNfaStartState;

  // Class representing NFA state.
  public static class NfaState {
    // Index of the state.
    public int index;
    // Set of allowed characters.
    public HashSet<Character> characters;
    // Next state indices.
    public HashSet<int> nextStates;
    // Initial state needs to transition to multiple states so the NFA will try
    // all possibilities.
    // TODO(sreeni) : Try and get rid of it at some point.
    public HashSet<int> compositeStates;
    // match kind if any. int.MAX_VALUE if this is not a final state.
    public int kind;

    NfaState(int index, HashSet<Character> characters,
             HashSet<int> nextStates, HashSet<int> compositeStates, int kind) {
      this.index = index;
      this.characters = characters;
      this.nextStates = nextStates;
      this.kind = kind;
      this.compositeStates = compositeStates;
    }
  }

  // The main nfa.
  public readonly Dictionary<int, NfaState> nfa = new Dictionary<int, NfaState>();

  public static enum MatchType {
    SKIP,
    SPECIAL_TOKEN,
    MORE,
    TOKEN,
  }

  // Match info.
  public static class MatchInfo {
    // string literal image in case this string literal token, null otherwise.
    public string image;
    // Kind index.
    public int kind;
    // Type of match.
    public MatchType matchType;
    // Any lexical state transition specified.
    public int newLexState;
    // Any lexical state transition specified.
    public string action;

    public MatchInfo(string image, int kind, MatchType matchType,
                     int newLexState, string action) {
      this.image = image;
      this.kind = kind;
      this.matchType = matchType;
      this.newLexState = newLexState;
      this.action = action;
    }
  }

  // On match info indexed by the match kind.
  public Dictionary<int, MatchInfo> allMatches = new Dictionary<int, MatchInfo>();

  // Initial nfa states indexed by lexical state.
  public Dictionary<int, int> initialStates;

  // Kind of the wildcard match (~[]) indexed by lexical state.
  public Dictionary<int, int> wildcardKind;

  // Name of lexical state - for debugging.
  public String[] lexStateNames;

  // DEFULAT lexical state index.
  public int defaultLexState;

  public void setParserName(string parserName) {
    this.parserName = parserName;
  }

  public void setDecls(string decls) {
    this.decls = decls;
  }

  public void setLiteralSequence(Dictionary<int, List<String>> literalSequence) {
    this.literalSequence = literalSequence;
  }

  public void setLiteralKinds(Dictionary<int, List<int>> literalKinds) {
    this.literalKinds = literalKinds;
  }

  public void setKindToNfaStartState(
      Dictionary<int, int> kindToNfaStartState) {
    this.kindToNfaStartState = kindToNfaStartState;
  }

  public void addNfaState(int index, HashSet<Character> characters,
                          HashSet<int> nextStates,
                          HashSet<int> compositeStates, int kind) {
    NfaState nfaState =
        new NfaState(index, characters, nextStates, compositeStates, kind);
    nfa.Add(index, nfaState);
  }

  public void setInitialStates(Dictionary<int, int> initialStates) {
    this.initialStates = initialStates;
  }

  public void setWildcardKind(Dictionary<int, int> wildcardKind) {
    this.wildcardKind = wildcardKind;
  }

  public void setLexStateNames(String[] lexStateNames) {
    this.lexStateNames = lexStateNames;
  }

  public void setDefaultLexState(int defaultLexState) {
    this.defaultLexState = defaultLexState;
  }

  public void updateMatchInfo(Dictionary<int, String> actions,
                              int[] newLexStateIndices,
                              long[] toSkip, long[] toSpecial,
                              long[] toMore, long[] toToken) {
    for (int i = 0; i < newLexStateIndices.Length; i++) {
      int vectorIndex = i >> 6;
      long bits = (1L << (i & 077));
      MatchType matchType = MatchType.TOKEN;
      if (toSkip.Length > vectorIndex && (toSkip[vectorIndex] & bits) != 0L) {
        matchType = MatchType.SKIP;
      } else if (toSpecial.Length > vectorIndex &&
                 (toSpecial[vectorIndex] & bits) != 0L) {
        matchType = MatchType.SPECIAL_TOKEN;
      } else if (toMore.Length > vectorIndex &&
                 (toMore[vectorIndex] & bits) != 0L) {
        matchType = MatchType.MORE;
      } else {
        //assert(toToken.Length > vectorIndex && (toToken[vectorIndex] & bits) != 0L);
        matchType = MatchType.TOKEN;
      }
      MatchInfo matchInfo =
          new MatchInfo(Options.getIgnoreCase()
                            ? null : RStringLiteral.allImages[i], i, matchType,
                        newLexStateIndices[i], actions.get(i));
      allMatches.Add(i, matchInfo);
    }
  }
}
