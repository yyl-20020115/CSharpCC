namespace CSharpCC.Parser;

// A simple class to hold the data generated by the tokenizer. This is passed to
// the code generators to produce code.
public class TokenizerData
{

    // Name of the parser as specified in the PARSER_BEGIN/PARSER_END block.
    public string parserName;

    // Decls coming from TOKEN_MGR_DECLS
    public string decls;

    // A map of <LexState, first char> to a sequence of literals indexed by:
    //      ((int0LexicalState << 16 | (int)c)
    // The literals in the list are all guaranteed to start with the char and re
    // sorted by length so that the "longest-match" rule is done trivially by
    // just going through the sequence in the order.
    // Since they are all literals, there is no duplication (JavaCC checks that)
    // and hence if a longer match is matched, no need to check the shorter match.
    public Dictionary<int, List<string>> literalSequence;

    // A map of list of kind values indexed by ((int0LexicalState << 16 | (int)c)
    // same key as before.
    public Dictionary<int, List<int>> literalKinds;

    // The NFA start state for a given string literal match. We use this to start
    // the NFA if needed after a literal match is completed.
    public Dictionary<int, int> kindToNfaStartState;

    // Class representing NFA state.
    public class NfaState
    {
        // Index of the state.
        public int index;
        // Set of allowed characters.
        public HashSet<char> characters;
        // Next state indices.
        public HashSet<int> nextStates;
        // Initial state needs to transition to multiple states so the NFA will try
        // all possibilities.
        // TODO(sreeni) : Try and get rid of it at some point.
        public HashSet<int> compositeStates;
        // match kind if any. int.MAX_VALUE if this is not a final state.
        public int kind;

        public NfaState(int index, HashSet<char> characters,
                 HashSet<int> nextStates, HashSet<int> compositeStates, int kind)
        {
            this.index = index;
            this.characters = characters;
            this.nextStates = nextStates;
            this.kind = kind;
            this.compositeStates = compositeStates;
        }
    }

    // The main nfa.
    public readonly Dictionary<int, NfaState> nfa = new ();

 
    // Match info.
    public class MatchInfo
    {
        // string literal image in case this string literal token, null otherwise.
        public string image;
        // Kind index.
        public int kind;
        // Type of match.
        public MatchTypes matchType;
        // Any lexical state transition specified.
        public int newLexState;
        // Any lexical state transition specified.
        public string action;

        public MatchInfo(string image, int kind, MatchTypes matchType,
                         int newLexState, string action)
        {
            this.image = image;
            this.kind = kind;
            this.matchType = matchType;
            this.newLexState = newLexState;
            this.action = action;
        }
    }

    // On match info indexed by the match kind.
    public Dictionary<int, MatchInfo> allMatches = new();

    // Initial nfa states indexed by lexical state.
    public Dictionary<int, int> initialStates;

    // Kind of the wildcard match (~[]) indexed by lexical state.
    public Dictionary<int, int> wildcardKind;

    // Name of lexical state - for debugging.
    public String[] lexStateNames;

    // DEFULAT lexical state index.
    public int defaultLexState;

    public void SetParserName(string parserName)
    {
        this.parserName = parserName;
    }

    public void SetDecls(string decls)
    {
        this.decls = decls;
    }

    public void SetLiteralSequence(Dictionary<int, List<string>> literalSequence)
    {
        this.literalSequence = literalSequence;
    }

    public void SetLiteralKinds(Dictionary<int, List<int>> literalKinds)
    {
        this.literalKinds = literalKinds;
    }

    public void SetKindToNfaStartState(
        Dictionary<int, int> kindToNfaStartState)
    {
        this.kindToNfaStartState = kindToNfaStartState;
    }

    public void AddNfaState(int index, HashSet<char> characters,
                            HashSet<int> nextStates,
                            HashSet<int> compositeStates, int kind)
    {
        var nfaState =
            new NfaState(index, characters, nextStates, compositeStates, kind);
        nfa.Add(index, nfaState);
    }

    public void SetInitialStates(Dictionary<int, int> initialStates)
    {
        this.initialStates = initialStates;
    }

    public void SetWildcardKind(Dictionary<int, int> wildcardKind)
    {
        this.wildcardKind = wildcardKind;
    }

    public void SetLexStateNames(String[] lexStateNames)
    {
        this.lexStateNames = lexStateNames;
    }

    public void SetDefaultLexState(int defaultLexState)
    {
        this.defaultLexState = defaultLexState;
    }

    public void UpdateMatchInfo(Dictionary<int, String> actions,
                                int[] newLexStateIndices,
                                ulong[] toSkip, ulong[] toSpecial,
                                ulong[] toMore, ulong[] toToken)
    {
        for (int i = 0; i < newLexStateIndices.Length; i++)
        {
            int vectorIndex = i >> 6;
            ulong bits = (1UL << (i & 077));
            MatchTypes matchType;
            if (toSkip.Length > vectorIndex && (toSkip[vectorIndex] & bits) != 0L)
            {
                matchType = MatchTypes.SKIP;
            }
            else if (toSpecial.Length > vectorIndex &&
                       (toSpecial[vectorIndex] & bits) != 0L)
            {
                matchType = MatchTypes.SPECIAL_TOKEN;
            }
            else if (toMore.Length > vectorIndex &&
                       (toMore[vectorIndex] & bits) != 0L)
            {
                matchType = MatchTypes.MORE;
            }
            else
            {
                //assert(toToken.Length > vectorIndex && (toToken[vectorIndex] & bits) != 0L);
                matchType = MatchTypes.TOKEN;
            }
            var matchInfo =
                new MatchInfo(Options.GetIgnoreCase()
                                  ? null : RStringLiteral.allImages[i], i, matchType,
                              newLexStateIndices[i], actions[i]);
            allMatches.Add(i, matchInfo);
        }
    }
}
